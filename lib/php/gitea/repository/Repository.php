<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace gitea\repository;

use \php\Boot;
use \datetime\utils\DateTimeUtils;
use \gitea\user\User;

/**
 * Represents a repository.
 */
class Repository {
	/**
	 * @var bool
	 * Value indicating whether to enable commit merging.
	 */
	public $allowMergeCommits;
	/**
	 * @var bool
	 * Value indicating whether to enable rebasing to merge commits.
	 */
	public $allowRebase;
	/**
	 * @var bool
	 * Value indicating whether to enable rebasing with explicit merge commits.
	 */
	public $allowRebaseExplicit;
	/**
	 * @var bool
	 * Value indicating whether to enable squashing to merge commits.
	 */
	public $allowSquashMerge;
	/**
	 * @var string
	 * The URL of the repository's avatar.
	 */
	public $avatarUrl;
	/**
	 * @var string
	 * The HTTP-based URL for cloning this repository.
	 */
	public $cloneUrl;
	/**
	 * @var \Date
	 * The date the repository was created.
	 */
	public $createdAt;
	/**
	 * @var string
	 * The name of the default branch.
	 */
	public $defaultBranch;
	/**
	 * @var string
	 * The repository description.
	 */
	public $description;
	/**
	 * @var ExternalTracker
	 * The settings of the external tracker.
	 */
	public $externalTracker;
	/**
	 * @var ExternalWiki
	 * The settings of the external wiki.
	 */
	public $externalWiki;
	/**
	 * @var int
	 * The number of forks of this repository.
	 */
	public $forksCount;
	/**
	 * @var string
	 * The full name.
	 */
	public $fullName;
	/**
	 * @var bool
	 * Value indicating whether this repository has issues.
	 */
	public $hasIssues;
	/**
	 * @var bool
	 * Value indicating whether this repository has pull requests.
	 */
	public $hasPullRequests;
	/**
	 * @var bool
	 * Value indicating whether this repository has a wiki.
	 */
	public $hasWiki;
	/**
	 * @var string
	 * The Gitea URL of this repository.
	 */
	public $htmlUrl;
	/**
	 * @var int
	 * The repository identifier.
	 */
	public $id;
	/**
	 * @var bool
	 * Value indicating whether to ignore whitespace for conflicts.
	 */
	public $ignoreWhitespaceConflicts;
	/**
	 * @var InternalTracker
	 * The settings of the internal tracker.
	 */
	public $internalTracker;
	/**
	 * @var bool
	 * Value indicating whether this repository is archived.
	 */
	public $isArchived;
	/**
	 * @var bool
	 * Value indicating whether this repository is empty.
	 */
	public $isEmpty;
	/**
	 * @var bool
	 * Value indicating whether this repository is a fork.
	 */
	public $isFork;
	/**
	 * @var bool
	 * Value indicating whether this repository is a mirror.
	 */
	public $isMirror;
	/**
	 * @var bool
	 * Value indicating whether this repository is private.
	 */
	public $isPrivate;
	/**
	 * @var bool
	 * Value indicating whether this repository is a template.
	 */
	public $isTemplate;
	/**
	 * @var string
	 * The repository name.
	 */
	public $name;
	/**
	 * @var int
	 * The number of open issues of this repository.
	 */
	public $openIssuesCount;
	/**
	 * @var int
	 * The number of open pull requests of this repository.
	 */
	public $openPullRequestsCount;
	/**
	 * @var string
	 * The original URL of this repository.
	 */
	public $originalUrl;
	/**
	 * @var User
	 * The repository owner.
	 */
	public $owner;
	/**
	 * @var Repository
	 * The parent repository, if this repository is a fork or a mirror.
	 */
	public $parent;
	/**
	 * @var Permission
	 * The repository permissions.
	 */
	public $permissions;
	/**
	 * @var int
	 * The number of releases of this repository.
	 */
	public $releasesCount;
	/**
	 * @var int
	 * The repository size, in kilobytes.
	 */
	public $size;
	/**
	 * @var string
	 * The SSH-based URL for cloning this repository.
	 */
	public $sshUrl;
	/**
	 * @var int
	 * The number of stars of this repository.
	 */
	public $starsCount;
	/**
	 * @var \Date
	 * The date the repository was updated.
	 */
	public $updatedAt;
	/**
	 * @var int
	 * The number of watchers of this repository.
	 */
	public $watchersCount;
	/**
	 * @var string
	 * The URL of the repository website.
	 */
	public $website;

	/**
	 * Creates a new repository from the specified JSON map.
	 * 
	 * @param mixed $map
	 * 
	 * @return Repository
	 */
	public static function fromJson ($map) {
		$model = new Repository((\Reflect::hasField($map, "id") && Boot::isOfType(\Reflect::field($map, "id"), Boot::getClass('Int')) ? \Reflect::field($map, "id") : -1));
		if (\Reflect::hasField($map, "allow_merge_commits") && is_bool(\Reflect::field($map, "allow_merge_commits"))) {
			$model->allowMergeCommits = \Reflect::field($map, "allow_merge_commits");
		}
		if (\Reflect::hasField($map, "allow_rebase") && is_bool(\Reflect::field($map, "allow_rebase"))) {
			$model->allowRebase = \Reflect::field($map, "allow_rebase");
		}
		if (\Reflect::hasField($map, "allow_rebase_explicit") && is_bool(\Reflect::field($map, "allow_rebase_explicit"))) {
			$model->allowRebaseExplicit = \Reflect::field($map, "allow_rebase_explicit");
		}
		if (\Reflect::hasField($map, "allow_squash_merge") && is_bool(\Reflect::field($map, "allow_squash_merge"))) {
			$model->allowSquashMerge = \Reflect::field($map, "allow_squash_merge");
		}
		if (\Reflect::hasField($map, "archived") && is_bool(\Reflect::field($map, "archived"))) {
			$model->isArchived = \Reflect::field($map, "archived");
		}
		if (\Reflect::hasField($map, "avatar_url") && is_string(\Reflect::field($map, "avatar_url"))) {
			$model->avatarUrl = \Reflect::field($map, "avatar_url");
		}
		if (\Reflect::hasField($map, "clone_url") && is_string(\Reflect::field($map, "clone_url"))) {
			$model->cloneUrl = \Reflect::field($map, "clone_url");
		}
		if (\Reflect::hasField($map, "created_at") && is_string(\Reflect::field($map, "created_at"))) {
			$model->createdAt = \Date::fromTime((DateTimeUtils::fromString(\Reflect::field($map, "created_at")) - 62135596800.0) * 1000);
		}
		if (\Reflect::hasField($map, "default_branch") && is_string(\Reflect::field($map, "default_branch"))) {
			$model->defaultBranch = \Reflect::field($map, "default_branch");
		}
		if (\Reflect::hasField($map, "description") && is_string(\Reflect::field($map, "description"))) {
			$model->description = \Reflect::field($map, "description");
		}
		if (\Reflect::hasField($map, "empty") && is_bool(\Reflect::field($map, "empty"))) {
			$model->isEmpty = \Reflect::field($map, "empty");
		}
		if (\Reflect::hasField($map, "external_tracker") && \Reflect::isObject(\Reflect::field($map, "external_tracker"))) {
			$model->externalTracker = ExternalTracker::fromJson(\Reflect::field($map, "external_tracker"));
		}
		if (\Reflect::hasField($map, "external_wiki") && \Reflect::isObject(\Reflect::field($map, "external_wiki"))) {
			$model->externalWiki = ExternalWiki::fromJson(\Reflect::field($map, "external_wiki"));
		}
		if (\Reflect::hasField($map, "fork") && is_bool(\Reflect::field($map, "fork"))) {
			$model->isFork = \Reflect::field($map, "fork");
		}
		if (\Reflect::hasField($map, "forks_count") && Boot::isOfType(\Reflect::field($map, "forks_count"), Boot::getClass('Int'))) {
			$model->forksCount = \Reflect::field($map, "forks_count");
		}
		if (\Reflect::hasField($map, "full_name") && is_string(\Reflect::field($map, "full_name"))) {
			$model->fullName = \Reflect::field($map, "full_name");
		}
		if (\Reflect::hasField($map, "has_issues") && is_bool(\Reflect::field($map, "has_issues"))) {
			$model->hasIssues = \Reflect::field($map, "has_issues");
		}
		if (\Reflect::hasField($map, "has_pull_requests") && is_bool(\Reflect::field($map, "has_pull_requests"))) {
			$model->hasPullRequests = \Reflect::field($map, "has_pull_requests");
		}
		if (\Reflect::hasField($map, "has_wiki") && is_bool(\Reflect::field($map, "has_wiki"))) {
			$model->hasWiki = \Reflect::field($map, "has_wiki");
		}
		if (\Reflect::hasField($map, "html_url") && is_string(\Reflect::field($map, "html_url"))) {
			$model->htmlUrl = \Reflect::field($map, "html_url");
		}
		if (\Reflect::hasField($map, "ignore_whitespace_conflicts") && is_bool(\Reflect::field($map, "ignore_whitespace_conflicts"))) {
			$model->ignoreWhitespaceConflicts = \Reflect::field($map, "ignore_whitespace_conflicts");
		}
		if (\Reflect::hasField($map, "internal_tracker") && \Reflect::isObject(\Reflect::field($map, "internal_tracker"))) {
			$model->internalTracker = InternalTracker::fromJson(\Reflect::field($map, "internal_tracker"));
		}
		if (\Reflect::hasField($map, "mirror") && is_bool(\Reflect::field($map, "mirror"))) {
			$model->isMirror = \Reflect::field($map, "mirror");
		}
		if (\Reflect::hasField($map, "name") && is_string(\Reflect::field($map, "name"))) {
			$model->name = \Reflect::field($map, "name");
		}
		if (\Reflect::hasField($map, "open_issues_count") && Boot::isOfType(\Reflect::field($map, "open_issues_count"), Boot::getClass('Int'))) {
			$model->openIssuesCount = \Reflect::field($map, "open_issues_count");
		}
		if (\Reflect::hasField($map, "open_pr_counter") && Boot::isOfType(\Reflect::field($map, "open_pr_counter"), Boot::getClass('Int'))) {
			$model->openPullRequestsCount = \Reflect::field($map, "open_pr_counter");
		}
		if (\Reflect::hasField($map, "original_url") && is_string(\Reflect::field($map, "original_url"))) {
			$model->originalUrl = \Reflect::field($map, "original_url");
		}
		if (\Reflect::hasField($map, "owner") && \Reflect::isObject(\Reflect::field($map, "owner"))) {
			$model->owner = User::fromJson(\Reflect::field($map, "owner"));
		}
		if (\Reflect::hasField($map, "parent") && \Reflect::isObject(\Reflect::field($map, "parent"))) {
			$model->parent = Repository::fromJson(\Reflect::field($map, "parent"));
		}
		if (\Reflect::hasField($map, "permissions") && \Reflect::isObject(\Reflect::field($map, "permissions"))) {
			$model->permissions = Permission::fromJson(\Reflect::field($map, "permissions"));
		}
		if (\Reflect::hasField($map, "private") && is_bool(\Reflect::field($map, "private"))) {
			$model->isPrivate = \Reflect::field($map, "private");
		}
		if (\Reflect::hasField($map, "release_counter") && Boot::isOfType(\Reflect::field($map, "release_counter"), Boot::getClass('Int'))) {
			$model->releasesCount = \Reflect::field($map, "release_counter");
		}
		if (\Reflect::hasField($map, "size") && Boot::isOfType(\Reflect::field($map, "size"), Boot::getClass('Int'))) {
			$model->size = \Reflect::field($map, "size");
		}
		if (\Reflect::hasField($map, "ssh_url") && is_string(\Reflect::field($map, "ssh_url"))) {
			$model->sshUrl = \Reflect::field($map, "ssh_url");
		}
		if (\Reflect::hasField($map, "stars_count") && Boot::isOfType(\Reflect::field($map, "stars_count"), Boot::getClass('Int'))) {
			$model->starsCount = \Reflect::field($map, "stars_count");
		}
		if (\Reflect::hasField($map, "template") && is_bool(\Reflect::field($map, "template"))) {
			$model->isTemplate = \Reflect::field($map, "template");
		}
		if (\Reflect::hasField($map, "updated_at") && is_string(\Reflect::field($map, "updated_at"))) {
			$model->updatedAt = \Date::fromTime((DateTimeUtils::fromString(\Reflect::field($map, "updated_at")) - 62135596800.0) * 1000);
		}
		if (\Reflect::hasField($map, "watchers_count") && Boot::isOfType(\Reflect::field($map, "watchers_count"), Boot::getClass('Int'))) {
			$model->watchersCount = \Reflect::field($map, "watchers_count");
		}
		if (\Reflect::hasField($map, "website") && is_string(\Reflect::field($map, "website"))) {
			$model->website = \Reflect::field($map, "website");
		}
		return $model;
	}

	/**
	 * Creates a new repository.
	 * 
	 * @param int $id
	 * 
	 * @return void
	 */
	public function __construct ($id) {
		$this->website = "";
		$this->watchersCount = 0;
		$this->updatedAt = null;
		$this->starsCount = 0;
		$this->sshUrl = "";
		$this->size = 0;
		$this->releasesCount = 0;
		$this->permissions = null;
		$this->parent = null;
		$this->owner = null;
		$this->originalUrl = "";
		$this->openPullRequestsCount = 0;
		$this->openIssuesCount = 0;
		$this->name = "";
		$this->isTemplate = false;
		$this->isPrivate = false;
		$this->isMirror = false;
		$this->isFork = false;
		$this->isEmpty = false;
		$this->isArchived = false;
		$this->internalTracker = null;
		$this->ignoreWhitespaceConflicts = false;
		$this->htmlUrl = "";
		$this->hasWiki = false;
		$this->hasPullRequests = false;
		$this->hasIssues = false;
		$this->fullName = "";
		$this->forksCount = 0;
		$this->externalWiki = null;
		$this->externalTracker = null;
		$this->description = "";
		$this->defaultBranch = "";
		$this->createdAt = null;
		$this->cloneUrl = "";
		$this->avatarUrl = "";
		$this->allowSquashMerge = false;
		$this->allowRebaseExplicit = false;
		$this->allowRebase = false;
		$this->allowMergeCommits = false;
		$this->id = $id;
	}
}

Boot::registerClass(Repository::class, 'gitea.repository.Repository');
